<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>BRICS_RN&nbsp;(Robust&nbsp;Navigation&nbsp;Library): Introduction to the BRICS Robust Navigation Library BRICS_RN.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BRICS_RN&nbsp;(Robust&nbsp;Navigation&nbsp;Library)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Introduction to the BRICS Robust Navigation Library BRICS_RN. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Robust navigation is the ability of a mobile robot to perform autonomous navigation while avoiding dangerous situations such as collisions with obstacles. It is a cross-sectional domain which includes path planning, motion control and sensor data processing.</p>
<p>The goal of the BRICS_RN library is, to unify several existing software libraries, that provide algorithms for (robust) navigation, into one coherent software framework. The purpose is, to allow an application developer, to easily choose from a set of existing algorithms, and to easily exchange those algorithm at a later stage in the application development process, without breaking any dependencies or application internal interfaces.</p>
<p>The following discussion is almost entirely taken from section 3 of the <a class="el" href="references.html#bib_bricsd33">BRICS deliverable D3.3</a> with some additional material from <a class="el" href="references.html#bib_brugali2012">[Brugali2012]</a>, sections 3.1 and 4.1.</p>
<h1><a class="anchor" id="taxonomy"></a>
Navigation Algorithms</h1>
<p>Mobile robot navigation algorithms can be roughly classified as one- and multi-step methods. One-step methods directly convert the sensor data to motion commands. The majority of one- step algorithms are either based on classical planning or on potential fields approaches <a class="el" href="references.html#bib_siciliano2008">[Siciliano2008]</a>. Today, they are rarely used due to their inability to cope with dynamic environments and vehicle constraints. Multi-step methods (e.g. Dynamic Window Approach <a class="el" href="references.html#bib_fox1997">[Fox1997]</a>, Vector Field Histogram <a class="el" href="references.html#bib_ulrich1998">[Ulrich1998]</a>, Nearness Diagram <a class="el" href="references.html#bib_minguez2004">[Minguez2004]</a>) overcome these limitations by creating a local map of the environment around the robot and performing local planning by computing possible motion directions (Nearness Diagram) and velocities (VHF) taking into account distance to the goal or to a precomputed path.</p>
<p>A complete navigation system consists usually of many more-or-less independent sub components, some examples, taken from <a class="el" href="references.html#bib_bricsd33">[BRICS deliverable D3.3]</a>, are listed below:</p>
<ul>
<li>Motion planning (aka BaseGlobalPlanner, PathPlanner) is the process of computing a collision-free global path in a static environment between a given start position and a given goal position. The path is typically represented as a sequence of intermediate waypoints. </li>
<li>Trajectory generation (aka ParameterizedTrajectoryGenerator, DWAPlanner) is the process of refining a path in order to introduce velocity information. A trajectory defines the planned positions of the robot over the time and is typically represented as a sequence of positions with an associated velocity. </li>
<li>Obstacle detection and representation (aka CostMap2D, OgMap) is the process of using sensor information (e.g. from laser scanners) in order to detect the positions of obstacles around the robot. This information is then used for creating and updating a map of the environment. </li>
<li>Obstacle avoidance (aka LocalBaseNavigation, LocalNav, CAbstractHolonomicReactiveMethod) is the process of adapting the precomputed trajectory while the robot is moving in order to avoid unexpected obstacles that occlude the path. Position and velocity control (aka LocalBaseNavigation, LocalNav, MotionController) is the process of generating velocity commands to the robot in order to move it along the computed trajectory. This functionality has a strong dependency with the kinematics model, which is often implicit in the library implementations. </li>
<li>Localization (aka FaithLocaliser, amcl): is the process of estimating the robot position with respect to a global reference frame. In the simplest case this functionality is implemented by using only the robot odometry but other sensors can be used to improve the odometric estimation. For example it is possible to use a camera for locating visual markers in the environment whose position is known in the global reference frame, and use this information for computing the robot position.</li>
</ul>
<h1><a class="anchor" id="intro_design"></a>
BRICS_RN Design Overview</h1>
<p>In many navigation systems, these components are rather tightly coupled. For example, the very popular ROS navigation stack exports a single ROS node called "move_base" as its public interface, which then creates all the other components. The <code>move_base</code> node and the other nodes communicate by standard ROS methods, including ROS-Services, ROS topics or direct calls. The generall architecture of ROS navigation stack is shown below (taken from <a class="el" href="references.html#bib_bricsd33">[BRICS_D3.3]</a>).</p>
<div class="image">
<img src="brics-rn-fig2b.png" alt="brics-rn-fig2b.png"/>
<div class="caption">
Simplified ROS navigation stack architecture.</div></div>
<p> In the BRICS_RN library, these sub components are grouped into four functional gropus and organized into a pipeline structure (image taken from <a class="el" href="references.html#bib_bricsd33">[BRICS_D3.3]</a>):</p>
<div class="image">
<img src="brics-rn-fig3.png" alt="brics-rn-fig3.png"/>
<div class="caption">
BRICS_RN generall architecture.</div></div>
<p> The following functional groups are used: </p>
<ul>
<li>Trajectory Planner implements the motion planning and trajectory generation functionalities. It gets a goal position, the current robot position and sensor observations as an input. Desired velocity profile and mobile-base kinematic and dynamic properties are configuration parameters. Trajectory Planner produces a trajectory that is a vector of poses with twist. </li>
<li>trajectory Adapter interpolates the precomputed trajectory and produces an obstacle-free trajectory toward the next waypoint taking into account the actual sensor information produced by the laser scanner. Mobile-base kinematic and dynamic properties are configuration parameters. </li>
<li>Trajectory Follower receives as input the adapted trajectory and the robot's estimated pose and produces as output a twist for following the input trajectory. </li>
<li>Optional component is coordinator, which implements the coordination logic among components. It monitors events generated by components that could represent abnormal situations (e.g. the Trajectory Adapter cannot generate a trajectory to avoid an obstacle) and generates events that triggers state changes in other components (e.g. the Trajectory Planner should plan a new trajectory).</li>
</ul>
<p>In BRICS_RN key functionalities are mapped to finer grained components. Each component has only one thread of control. This allows to replace individual functionalities easier and to select the most appropriate frequency for each functionality. Coordination mechanisms have been made independent from the components implementations by introducing a Coordinator component. Robot kinematics and dynamics are taken into account during trajectory planning and adaptation. The following diagram shows the BRICS_RN components in greater detail, including their connection to relevant other parts of a robot system.</p>
<div class="image">
<img src="brics-rn-fig4.png" alt="brics-rn-fig4.png"/>
<div class="caption">
BRICS_RN components and interfaces towards other services.</div></div>
<p> Continuous lines depict the default connections between input and output ports while dashed lines represent the optional connections that may be created to configure a specific application. Continuous boxes represent mandatory components, while dashed boxes represent optional components. Boxes inside components indicate their properties.</p>
<p>More specifically: </p>
<ul>
<li>Trajectory Planner implements the motion planning and trajectory generation functionalities. It gets a goal position and the current robot position as input and produces a trajectory that is a vector of poses with twist. </li>
<li>Trajectory Adapter interpolates the precomputed trajectory and produces an obstacle-free trajectory toward the next waypoint taking into account the sensor information produced by the laser scanner. </li>
<li>Trajectory Follower receives the adapted trajectory and the robot estimated pose and produces as output a twist for following the input trajectory. </li>
<li>Robot Driver drives the physical robot. It receives twist commands and produces the robot odometry. </li>
<li>Laser Scanner Driver reads the raw data from the device and produces as output the laser scans expressed as a vector of distances and angles. </li>
<li>Pose Tracker keeps track of the current pose and twist of the robot. It fuses odometry estimates with position estimates computed by other components. </li>
<li>Marker Locator is an optional component, which is in charge of localizing visual markers placed in the environment and computing their positions with respect to a global reference frame. It receives as input an image and the odometry of the robot and produces as output the absolute marker position. </li>
<li>RGB Camera Driver is an optional component, which reads data from the RGB camera and produces as output an RGB image. </li>
<li>Coordinator implements the coordination logic among components. It monitors events generated by components that could represent abnormal situations (e.g. the Trajectory Adapter cannot generate a trajectory to avoid an obstacle) and generates events that triggers state changes in other components (e.g. the Trajectory Planner should plan a new trajectory).</li>
</ul>
<p>There are some important differences between the proposed BRICS_RN solution and the ROS navigation stack. First of all the navigation functionalities are mapped to finer grained components. Each component has only one thread of control. This allows to replace individual functionalities easier and to select the most appropriate frequency for each functionality.</p>
<p>Accordingly, the trajectory follower and the trajectory adapter functionalities are implemented in two different components, in <a class="el" href="TrajectoryAdapterNode_8cpp.html">TrajectoryAdapterNode.cpp</a> and <a class="el" href="TrajectoryFollowerNode_8cpp.html">TrajectoryFollowerNode.cpp</a> . This separation reflects the different operating frequencies of the two components: the Trajectory Follower runs at a higher frequency, as required by the closed loop position and velocity control algorithm. On the contrary the Trajectory Adapter component computes a new output only when receives a new laser scan or a new trajectory.</p>
<p>Unlike in ROS, the coordination mechanisms have been made independent from the components implementations by introducing a Coordinator component. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 22 2013 11:48:02 for BRICS_RN&nbsp;(Robust&nbsp;Navigation&nbsp;Library) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
