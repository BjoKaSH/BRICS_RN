<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BRICS_RN_Robust_Navigation_Library(BRICS_RN): Tutorials</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BRICS_RN_Robust_Navigation_Library(BRICS_RN)&#160;<span id="projectnumber">0.01</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Tutorials </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="tutorials.html">Tutorials</a><ul>
<li><a class="el" href="tutorials.html#point_tutorial">Understanding the 3D point data-type</a></li>
<li><a class="el" href="tutorials.html#point_cloud_tutorial">Understanding the 3D point cloud data-type</a></li>
<li><a class="el" href="tutorials.html#transformation_tutorial">Understanding the rigid transformation data-type</a></li>
<li><a class="el" href="tutorials.html#triangle_mesh_tutorial">Understanding the triangle mesh data-type</a></li>
<li><a class="el" href="tutorials.html#visualizer_tutorial">Understanding the vizualizer</a></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="point_tutorial"></a>
Understanding the 3D point data-type</h2>
<p>The Cartesian point representation is implemented in the class brics_3d::Point3D. A single point is represented be the coordinated whereas each coordinate <img class="formulaInl" alt="$ x, y, z $" src="form_5.png"/> has a dedicated variable. To be able to choose the data-type at compile time, the Coordinate data-type can be changed by adjusting a typedef for the coordinate type: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keywordtype">double</span> Coordinate;
</pre></div><p>Possibilities to create points are illustrates as follows:</p>
<div class="fragment"><pre class="fragment">        Point3D myPoint();
        myPoint.setX(1.0);
        myPoint.setX(2.0);
        myPoint.setX(3.0);
        
        std::cout &lt;&lt; myPoint.getX();
        std::cout &lt;&lt; myPoint.getY();
        std::cout &lt;&lt; myPoint.getZ();
        
        Point3D mySecondPoint(0,0,0);   
        Point3D *point000 = <span class="keyword">new</span> Point3D();
        Point3D *point111 = <span class="keyword">new</span> Point3D(1, 1, 1);
        Point3D *pointMinus123 = <span class="keyword">new</span> Point3D(-1.0, -2.0, -3.0); 
</pre></div><p>The coordinate values can be easily accessed and with the steaming operator <code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code> . Printing a point to the standard output is convenient, as it means just invoking: </p>
<div class="fragment"><pre class="fragment">        std::cout &lt;&lt; myPoint;
</pre></div><p>The basic vector algebra is implemented with operators. The operators <code>operator+</code> and <code>operator−</code> allow to add and subtract two points, while the <code>operator∗</code> enables multiplication with a scalar value. The homogeneous transformation is an important function for the Cartesian point representation and is implemented in the function: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">virtual</span> <span class="keywordtype">void</span> homogeneousTransformation(IHomogeneousMatrix44 ∗transformation);
</pre></div><p>Further information on the transformation representation can be found in section <a class="el" href="tutorials.html#transformation_tutorial">Understanding the rigid transformation data-type</a></p>
<p>A point might have additional information like color or a normal vector. To allow good extendability, the <em>decorator</em> <em>pattern</em> is applied. The Point3DDecorator has the same interface as the brics_3d::Point3D as it inherits from it. Additionally it holds a reference to an instance of a brics_3d::Point3D. Whenever a function of the decorator is invoked it is internally forwarded to this point reference.</p>
<p>An example realization of a point extension, is the brics_3d::ColoredPoint3D class that adds new variables for the additional color information. It inherits form the brics_3d::Point3DDecorator, thus it can wraps a point into a layer or skin that appears to the outer world as a regular Point3D, but internally it has additional information that is accessible with the brics_3d::ColoredPoint3D interface. It is possible to perform multiple decorations on a point. In this case, it can be seen as some kind of onion that has different layers - each adds a new portion of information. Queries to the outer layer brics_3d::Point3D are forwarded to the core in cascaded way.</p>
<p>This code snippet demonstrates how to create points with a color decoration: </p>
<div class="fragment"><pre class="fragment">        ColoredPoint3D *point000 = <span class="keyword">new</span> ColoredPoint3D(<span class="keyword">new</span> Point3D());                                  <span class="comment">// default constructors</span>
        ColoredPoint3D *point111 = <span class="keyword">new</span> ColoredPoint3D(<span class="keyword">new</span> Point3D(1, 1, 1), 1, 1, 1);                  <span class="comment">// x=1, y=1, z=1, red=1, green=1, blue=1 </span>
        ColoredPoint3D *pointMinus123 = <span class="keyword">new</span> ColoredPoint3D(<span class="keyword">new</span> Point3D(-1.0, -2.0, -3.00), 1, 1, 1);   <span class="comment">// x=-1.0, y=-2.0, z=-3.00, red=1, green=1, blue=1</span>
</pre></div><h2><a class="anchor" id="point_cloud_tutorial"></a>
Understanding the 3D point cloud data-type</h2>
<p>The point cloud is essentially a collection of Cartesian points.</p>
<p>It consist of a vector of points: <code>std::vector&lt;Point3D&gt;∗</code> <code>pointCloud</code>; . The reference to the vector can be accessed via the getPointCloud method. The vector can contain either normal points of type Point3D or decorated points. Actually for the point cloud there is no difference.</p>
<p>The point cloud class brics_3d::PointCloud3D implements abilities to apply a homogeneous transformation to all points. The brics_3d::PointCloud3D::homogeneousTransformation method forwards the brics_3d::IHomogeneousMatrix44 to every point in the vector. A similar behavior have the streaming methods <code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code>, as data is forwarded from or to the points as explained earlier.</p>
<p>An example on how to use a point cloud with Cartesian points is given as follows: </p>
<div class="fragment"><pre class="fragment">        <span class="comment">/* create some points */</span>
        Point3D *point000 = <span class="keyword">new</span> Point3D(0,0,0);
        Point3D *point001 = <span class="keyword">new</span> Point3D(0,0,1);
        Point3D *point011 = <span class="keyword">new</span> Point3D(0,1,1);
        Point3D *point010 = <span class="keyword">new</span> Point3D(0,1,0);
        Point3D *point100 = <span class="keyword">new</span> Point3D(1,0,0);
        Point3D *point101 = <span class="keyword">new</span> Point3D(1,0,1);
        Point3D *point111 = <span class="keyword">new</span> Point3D(1,1,1);
        Point3D *point110 = <span class="keyword">new</span> Point3D(1,1,0);

        <span class="comment">/* create new point cloud */</span>
        PointCloud3D* pointCloudCube = <span class="keyword">new</span> PointCloud3D();

        <span class="comment">/* fill up point cloud with previously created points */</span>
        pointCloudCube-&gt;addPoint(point000); 
        pointCloudCube-&gt;addPoint(point001);
        pointCloudCube-&gt;addPoint(point011);
        pointCloudCube-&gt;addPoint(point010);
        pointCloudCube-&gt;addPoint(point100);
        pointCloudCube-&gt;addPoint(point101);
        pointCloudCube-&gt;addPoint(point111);
        pointCloudCube-&gt;addPoint(point110);

        <span class="comment">/* modify data of first element */</span>
        (*pointCloudCube-&gt;getPointCloud())[0].setX(100);
        (*pointCloudCube-&gt;getPointCloud())[0].setY(200);
        (*pointCloudCube-&gt;getPointCloud())[0].setZ(300);
        
        <span class="comment">/* get access to data */</span>
        Point3D resultPoint = (*pointCloudCube-&gt;getPointCloud())[0];
        std:cout &lt;&lt; resultPoint.getX();
        std:cout &lt;&lt; resultPoint.getY();
        std:cout &lt;&lt; resultPoint.getZ();

        <span class="comment">/* clean up */</span>
        <span class="keyword">delete</span> pointCloudCube;
</pre></div><h2><a class="anchor" id="transformation_tutorial"></a>
Understanding the rigid transformation data-type</h2>
<p>The brics_3d::IHomogeneousMatrix44 class is an abstract interface to a homogeneous transformation matrix. This abstract class has essentially one function brics_3d::IHomogeneousMatrix44::getRawData that returns a pointer to a data array that stores the values of the transformation matrix. This array stores the values in <b>column-row</b> order and has a fixed of size <img class="formulaInl" alt="$ 16 $" src="form_6.png"/>. This is the most general and simplest form to represent a matrix. The interface also has functions to multiply matrices with each other, to print the values with the streaming operator <code>operator&lt;&lt;</code> or assign new values with the <code>operator=</code> function.</p>
<p>The interface is implemented in the brics_3d::HomogeneousMatrix44 class. It uses the Eigen library to implement matrix multiplications and convenient set-up in the class constructor. The transformation function in brics_3d::Point3D depends only on the abstract interface, rather on the implementation of the homogeneous matrix. This conforms to the <em>Dependency</em> <em>Inversion</em> Principle.</p>
<p>The following code section shall illustrate on how to use the HomogeneousMatrix44:</p>
<div class="fragment"><pre class="fragment">        <span class="comment">/* create some matrices */</span>
        HomogeneousMatrix44 *identityMatrix = <span class="keyword">new</span> HomogeneousMatrix44();
        IHomogeneousMatrix44 *myMatrix = <span class="keyword">new</span> HomogeneousMatrix44(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 1.0, 2.0, 3.0);
        
        <span class="comment">/* get access translation part*/</span>
        <span class="keyword">const</span> <span class="keywordtype">double</span>* matrixPtr;
        matrixPtr = myMatrix-&gt;getRawData();
                
        std:cout &lt;&lt; matrixPtr[12]; 
        std:cout &lt;&lt; matrixPtr[13];
        std:cout &lt;&lt; matrixPtr[14];
        
        <span class="comment">/* print out complete matrix */</span>
        std::cout &lt;&lt; *myMatrix;
</pre></div><h2><a class="anchor" id="triangle_mesh_tutorial"></a>
Understanding the triangle mesh data-type</h2>
<p>Triangle meshes are often represented in an <em>implicit</em> or an <em>explicit</em> manner. The brics_3d::TriangleMeshImplicit class implements the implicit version. It has a vector vertices that holds the points of type brics_3d::Point3D. In combination with the indices vector triangles can be represented. The explicit mesh representation brics_3d::TriangleMeshExplicit has a vector of triangles. Each triangle is modeled by the class brics_3d::Triangle. It has an array of dimension <img class="formulaInl" alt="$ 3 $" src="form_7.png"/> to store the vertices belonging to a triangle. Both mesh implementations allow access to their individual vectors via <code>getter</code> and <code>setter</code> methods.</p>
<p>To make both variants exchangeable, they share the same interface brics_3d::ITriangleMesh. It gives a common access to a the vertices of a triangle via: brics_3d::ITriangleMesh::getTriangleVertex. Triangles can be added and removed with brics_3d::ITriangleMesh::addTriangle and brics_3d::ITriangleMesh::removeTriangle. The adequate maintenance of the underling structures has to be handled different by both mesh implementations. The interface offers functionality to apply homogeneous transformation matrices. To transform a mesh, the matrix is propagated to the stored brics_3d::Point3D objects.</p>
<p>Streaming capabilities are available by the <code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code> methods, similar to a point cloud.</p>
<p>Examples usage for am <em>implicit</em> and <em>explicit</em> triangle meshes are given below: </p>
<div class="fragment"><pre class="fragment">        <span class="comment">/* crate some sample data */</span>
        Point3D *vertex000 = <span class="keyword">new</span> Point3D(0,0,0);
        Point3D *vertex100 = <span class="keyword">new</span> Point3D(1,0,0);
        Point3D *vertex101 = <span class="keyword">new</span> Point3D(1,0,1);
        Point3D *vertex001 = <span class="keyword">new</span> Point3D(0,0,1);
        Point3D *vertex110 = <span class="keyword">new</span> Point3D(1,1,0);
        Point3D *vertex111 = <span class="keyword">new</span> Point3D(1,1,1);

        ITriangleMesh *mesh; <span class="comment">// generic interface for a triangle mesh</span>
 
        <span class="comment">/* create implicit mesh  */</span> 
        mesh = <span class="keyword">new</span> TriangleMeshImplicit();
        mesh-&gt;addTriangle(*vertex000, *vertex100, *vertex101);
        mesh-&gt;addTriangle(*vertex101, *vertex001, *vertex000);
        mesh-&gt;addTriangle(*vertex100, *vertex110, *vertex111);
        mesh-&gt;addTriangle(*vertex100, *vertex110, *vertex111);
        
        std::cout &lt;&lt; mesh-&gt;getSize();             <span class="comment">// = 4</span>
        std::cout &lt;&lt; mesh-&gt;getNumberOfVertices()  <span class="comment">// = 12</span>
  
        <span class="keyword">delete</span> mesh;
    
        <span class="comment">/* create explicit mesh  */</span>
        mesh = <span class="keyword">new</span> TriangleMeshExplicit();
        mesh-&gt;addTriangle(*vertex000, *vertex100, *vertex101);
        mesh-&gt;addTriangle(*vertex101, *vertex001, *vertex000);
        mesh-&gt;addTriangle(*vertex100, *vertex110, *vertex111);
        mesh-&gt;addTriangle(*vertex100, *vertex110, *vertex111);
        
        std::cout &lt;&lt; mesh-&gt;getSize();             <span class="comment">// = 4</span>
        std::cout &lt;&lt; mesh-&gt;getNumberOfVertices()  <span class="comment">// = 12</span>

        <span class="keyword">delete</span> mesh;
</pre></div><h2><a class="anchor" id="visualizer_tutorial"></a>
Understanding the vizualizer</h2>
<p>The visualization capabilities are realized with the OSG library. Point clouds and triangle meshes can be displayed. In OSG it is benefitial for huge point clouds, to partition them into bunches of approximately no more than 10, 000 points. Otherwise the performance drops significantly. The partition into multiple bunches accounts for the parallel architecture of the graphics adapter hardware. This is done automatically within the visualizer implementation.</p>
<p>To visualize a point cloud you can use the brics_3d::OSGPointCloudVisualizer() </p>
<div class="fragment"><pre class="fragment">        <span class="comment">/* visualize point cloud */</span>
        OSGPointCloudVisualizer* visualizer = <span class="keyword">new</span> OSGPointCloudVisualizer();
        visualizer-&gt;visualizePointCloud(pointCloudCube);
</pre></div><p>If you want to visualize triangle meshed you can use the brics_3d::OSGTriangleMeshVisualizer()</p>
<div class="fragment"><pre class="fragment">        <span class="comment">/* visualize triangle mesh */</span>
        OSGTriangleMeshVisualizer* visualizer = <span class="keyword">new</span> OSGTriangleMeshVisualizer();
        visualizer-&gt;addTriangleMesh(mesh);
        visualizer-&gt;visualize();
</pre></div><p>Please not that <code>visualizer-&gt;visualize()</code>; is a blocking call, but you can continue execution by pressing <code>ESC</code>. </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Oct 22 2012 16:10:36 for BRICS_RN_Robust_Navigation_Library(BRICS_RN) by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
